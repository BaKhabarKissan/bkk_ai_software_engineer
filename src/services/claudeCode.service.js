const { spawn } = require("child_process");
const path = require("path");
const fs = require("fs");
const { logger } = require("./log.service");

const { CLAUDE_CODE_PATH, REPOS_BASE_PATH, JIRA_HOST } = process.env;

// Default to 'claude' assuming it's in PATH
const claudeCodePath = CLAUDE_CODE_PATH || "claude";
const reposBasePath = REPOS_BASE_PATH || "D:/repos/repositories";

function parseGitHubUrl(url) {
    const match = url.match(/github\.com\/([^/]+)\/([^/.]+)/);
    if (!match) {
        throw new Error(`Invalid GitHub URL: ${url}`);
    }
    return { owner: match[1], repo: match[2] };
}

function generateBranchName(issueKey, issueType) {
    const prefix = issueType?.toLowerCase() === "bug" ? "bug" : "feature";
    return `${prefix}/${issueKey}`;
}

function buildFullPrompt(issue, repoUrl, branchName, jiraTaskUrl) {
    const parts = [
        "# Automated Task Implementation",
        "",
        "You are an autonomous AI agent tasked with implementing a Jira ticket.",
        "Follow ALL the steps below in order.",
        "",
        "---",
        "",
        "## Step 1: Clone Repository",
        "",
        `Clone this repository: ${repoUrl}`,
        "",
        "If the repository already exists locally, pull the latest changes from the main branch.",
        "",
        "## Step 2: Create Branch",
        "",
        `Create and checkout a new branch named: \`${branchName}\``,
        "",
        "If the branch already exists, checkout to it and pull latest changes.",
        "",
        "## Step 3: Implement the Task",
        "",
        `### Jira Task: ${issue.key}`,
        "",
        `**Summary:** ${issue.summary}`,
        "",
        "**Description:**",
        issue.description?.text || "No description provided",
        "",
    ];

    // Add comments if any
    if (issue.comments && issue.comments.length > 0) {
        parts.push("**Comments:**");
        for (const comment of issue.comments) {
            parts.push(`- ${comment.author} (${comment.created}): ${comment.body?.text || ""}`);
        }
        parts.push("");
    }

    parts.push(
        "**Implementation Guidelines:**",
        "- Implement the task as described above",
        "- Follow existing coding standards and patterns in the codebase",
        "- Write clean, maintainable code",
        "- Run linting/formatting if configured",
        "",
        "## Step 4: Commit Changes",
        "",
        "After implementing, commit your changes with this message:",
        `\`${issue.key}: ${issue.summary}\``,
        "",
        "## Step 5: Push Branch",
        "",
        `Push the branch \`${branchName}\` to the remote origin.`,
        "",
        "## Step 6: Create Pull Request",
        "",
        "Create a Pull Request with:",
        `- **Title:** \`${issue.key}: ${issue.summary}\``,
        "- **Base branch:** main (or the default branch)",
        `- **Head branch:** \`${branchName}\``,
        "",
        "**PR Description:**",
        "```",
        "## Summary",
        "",
        issue.summary,
        "",
        "## Jira Task",
        "",
        `[${issue.key}](${jiraTaskUrl})`,
        "",
        "## Description",
        "",
        issue.description?.text || "No description provided",
        "",
        "---",
        "",
        "*This PR was automatically generated by Claude Code automation.*",
        "```",
        "",
        "---",
        "",
        "## Important Notes",
        "",
        "- Complete ALL steps above",
        "- If any step fails, report the error clearly",
        "- Do not ask for confirmation - proceed autonomously",
        "- After creating the PR, output the PR URL",
        ""
    );

    return parts.join("\n");
}

async function runClaudeCode(issue, repoUrl, txnId) {
    logger.info(`[${txnId}] claudeCode.service.js [runClaudeCode] Starting Claude Code for issue: ${issue.key}`);

    const { owner } = parseGitHubUrl(repoUrl);
    const branchName = generateBranchName(issue.key, issue.issueType?.name);
    const jiraTaskUrl = `${JIRA_HOST}/browse/${issue.key}`;

    // Ensure base directory exists
    const ownerPath = path.join(reposBasePath, owner);
    if (!fs.existsSync(ownerPath)) {
        fs.mkdirSync(ownerPath, { recursive: true });
        logger.debug(`[${txnId}] claudeCode.service.js [runClaudeCode] Created directory: ${ownerPath}`);
    }

    const prompt = buildFullPrompt(issue, repoUrl, branchName, jiraTaskUrl);

    logger.debug(prompt, `[${txnId}] claudeCode.service.js [runClaudeCode] Generated prompt`);

    return new Promise((resolve, reject) => {
        // Use --print with stdin for the prompt to avoid Windows command line length limits
        const args = [
            "--print",                          // Non-interactive mode, outputs result
            "--dangerously-skip-permissions",   // Skip permission prompts for automation
        ];

        logger.info(`[${txnId}] claudeCode.service.js [runClaudeCode] Spawning Claude Code CLI`);
        logger.info(`[${txnId}] claudeCode.service.js [runClaudeCode] Working directory: ${ownerPath}`);
        logger.info(`[${txnId}] claudeCode.service.js [runClaudeCode] Prompt length: ${prompt.length} chars`);

        const claude = spawn(claudeCodePath, args, {
            cwd: ownerPath,
            shell: true,   // Enable shell to find claude in PATH
            windowsHide: true,
            stdio: ["pipe", "pipe", "pipe"],  // Enable stdin
            env: {
                ...process.env,
                // Ensure Claude Code can access git credentials
                GIT_TERMINAL_PROMPT: "0",
            },
        });

        let stdout = "";
        let stderr = "";

        claude.stdout.on("data", (data) => {
            const output = data.toString();
            stdout += output;
            // Log output in real-time for monitoring
            logger.info(`[${txnId}] claudeCode.service.js [runClaudeCode] stdout: ${output.trim()}`);
        });

        claude.stderr.on("data", (data) => {
            const output = data.toString();
            stderr += output;
            logger.warn(`[${txnId}] claudeCode.service.js [runClaudeCode] stderr: ${output.trim()}`);
        });

        claude.on("close", (code) => {
            logger.info(`[${txnId}] claudeCode.service.js [runClaudeCode] Claude Code exited with code: ${code}`);

            if (code === 0) {
                // Try to extract PR URL from output
                const prUrlMatch = stdout.match(/https:\/\/github\.com\/[^\s]+\/pull\/\d+/);
                const prUrl = prUrlMatch ? prUrlMatch[0] : null;

                resolve({
                    success: true,
                    exitCode: code,
                    output: stdout,
                    stderr: stderr,
                    branchName,
                    prUrl,
                });
            } else {
                reject(new Error(`Claude Code exited with code ${code}: ${stderr || stdout}`));
            }
        });

        claude.on("error", (error) => {
            logger.error(`[${txnId}] claudeCode.service.js [runClaudeCode] Failed to spawn Claude Code: ${error.message}`);
            reject(error);
        });

        // Send prompt via stdin and close it
        claude.stdin.write(prompt);
        claude.stdin.end();
        logger.info(`[${txnId}] claudeCode.service.js [runClaudeCode] Sent prompt via stdin`);
    });
}

module.exports = {
    runClaudeCode,
    buildFullPrompt,
    parseGitHubUrl,
    generateBranchName,
};
